##-----------------------------------------------------------------------------
## 
## Module = cachematrix.R                      (enhanced to spec by reggiemack)
## 
## This module contains 2 functions, makeCacheMatrix & cacheSolve. Together they
## facilitate the elimination of redundant, matrix inverse calculations. This is
## especially useful on large matrices given the significant cost of an inverse
## matrix computation. This is accomplished by cache'ing the the matrix and its
## calculated inverse, outside of the lexical scope of the functions operating
## on the matrices by the use of R's "<<-" operator. Thus, this "R" coding idiom
## can be utilized to improve significantly, the performance of any R programs 
## that have heavy and repetitive computational tasks. Here, the idiom is used
## along with the solve function to compute the inverse of invertible matrices.
## 
## Although not required by this assignment (#2), any interested, may test this 
## script by reviewing/running the testCacheMatrix.R script in this very same
## repository. (i.e., https://github.com/reggiemack-310/ProgrammingAssignment2)
##
## makeCacheMatrix:
##     
##     makeCacheMatrix initializes the current environment with the matrix to be
##     inverted and generates a list of named functions that will facilitate 
##     the setting and getting of the "cache" variables. The functions generated
##     into the returned list are:
##          
##         set & get which ship the matrix to be inverted, in and out of "cache"
##         setSolve & getSolve which ferry the inverted matrix in and out of
##         "cache"
##         
##         Thus the list of 4 named functions generated by, and returned from,  
##         the makeCacheMatrix function.
##
##         This function is run once to initialize and generate the cache, and
##         the list of functions to manipulate them.  This function must be  
##         executed (successfully) to utilize the cacheSolve function.
##
## 
## cacheSolve:
## 
##     The cacheSolve function either computes the inverse of an invertible matrix 
##     or retrieves the precomputed inverse from "cache". Passed to this function 
##     is the list of named functions generated by makeCacheMatrix and the 
##     matrix to be inverted.  This function will:
## 
##         Test for the existence of a cached inverse and if it exists and the  
##         matrix cached is the same as that passed then return the inverse  
##         retrieved from cache along with a message indicating said retrieval.  
##         Otherwise, cache the new invertible matrix to be inverted, compute  
##         its inverse, cache it and return the freshly computed inverse.
##     
##     This function may be run as many times as needed. But the makeCacheMatrix
##     function must have been executed first at least once.
## 
## 
## Usage:
##     
##     To use this tandem, run makeCacheMatrix to initialize the process. Then
##     run cacheSolve as needed.
## 
##     x <- makeCacheMatrix(someInvertibleMatrix1)
## 
##     xInv1 <- cacheSolve(x,someInvertibleMatrix1)
## 
##     When using cacheSolve again with the same matrix, a message will be
##     generated indicating that the solution was retrieved  from cache.
##     (i.e., "getting cached matrix ...")
## 
##     When the inverse is requested of a different invertible matrix via the 
##     cacheSolve function the new matrix is cached, its inverse calculated & 
##     cached, and its inverse returned.
##     
##     xInv2 <- cacheSolve(x,anotherInvertibleMatrix2)
## 
## 
## Example:
##     
##     As an example, let's run these functions to compute the inverse of a 
##     couple of matrices. This example assumes that the tandem functions
##     have been "source'd" into the current working directory and that there 
##     exists an invertible matrix "m".
## 
##     1. Initialize. 
##        x <- makeCacheMatrix(m)      # Assign the list of named functions to x
## 
##     2. Compute the inverse of m and assign to xInv1.
##        mInv1 <- cacheSolve(x,m)     # The inverse of m is computed and 
##                                     # assigned to mInv1
## 
##     3. Compute the inverse of m again and assign to mInv2.
##        mInv2 <- cacheSolve(x,m)     # This time the inverse is retrieved 
##                                     # from cache, indicated by the message:
##                                     # "getting cached matrix ..."
## 
##     4. Compute the inverse of mInv2 (which happens to be the inverse of m) 
##        and assign to mInv3.
##        mInv3 <- cacheSolve(x,mInv2) # Here, the inverse of mInv2 is computed 
##                                     # and stowed in mInv3
## 
##     Now, given that mInv3 is the inverse of mInv2 which happens to be the 
##     inverse of m, mInv3 and m should be identical matrices ...
## 
##-----------------------------------------------------------------------------

##-----------------------------------------------------------------------------
## 
## makeCacheMatrix:
## 
##     This function creates a list of functions that will
##     manipulate the caching of both the matrix itself and
##     computed inverse of the matrix passed, with getter &
##     setter functions for each.
##     parameter(s) passed to this function:
##     x ==> the initial "invertible" matrix to be cached and its inverse
##           computed.
##
##-----------------------------------------------------------------------------

makeCacheMatrix <- function(x = matrix()) {  # beg function
  
  m <- NULL                                  # clear local 
  set <- function(y) {                       # define set function: (passing y)
    x <<- y                                  #        cache (invertible matrix) y with x
    m <<- NULL                               #        clear (inverted matrix) cache m
  }
  get <- function() x                        # define get function: retrieve & return cached invertible matrix x
  setsolve <- function(solve) m <<- solve    # define setsolve function: cache inverted matrix to m by solve
  getsolve <- function() m                   # define getsolve function: retrieve & return cached inverted matrix m
  list(                                      # create a list of 4 elements where 
    set = set, get = get,                    #        each element is 1 of the 
    setsolve = setsolve,                     #        4 functions defined just 
    getsolve = getsolve                      #        prior
  )                                          # return the list
  
}                                            # end function


##-----------------------------------------------------------------------------
## 
## cacheSolve: 
##
##     This function returns a matrix that is the inverse of the invertible 
##     matrix argument passed to it.  It returns either the calculated inverse 
##     of the matrix passed or if the inverse of the matrix to be inverted
##     has been computed and cached already (i.e., if the matrix passed and
##     the matrix cached are identical to each other), then the pre-calculated
##     matrix inverse is returned from cache.
##
##     parameters passed to this function:
##     X ==> function list generated by makeCacheVector
##     y ==> "invertible" matrix to be inverted
##     ...   additional parameter(s) to be passed on through to the solve() 
##           function as needed. (see ?solve)
## 
##-----------------------------------------------------------------------------

cacheSolve <- function(x, y=matrix(), ...) { # beg function
  
  m <- x$getsolve()                          # retrieve invertible matrix from cache
  if(!is.null(m)&&identical(y,x$get())) {    # if cached & identical to passed matrix
    message("getting cached matrix ...")     #    indicate so by issuing retrieval message
    return(m)                                #    exit, returning the cached inverse
  } else {                                   # otherwise
    x$set(y)                                 #    cache the new invertible matrix
  }                                          # end if
  data <- x$get()                            # retrieve the new invertible matrix
  m <- solve(data, ...)                      # compute its inverse
  x$setsolve(m)                              # cache the inverse
  m                                          # exit, returning the computed inverse
  
}                                            # end function